# -*- mode: shell-script  -*-
#
# NOTE: emacs call this header line "file variables"
# https://www.gnu.org/software/emacs/manual/html_node/emacs/Specifying-File-Variables.html

# Uncomment here and at the bottom of this file to profile this file
# zmodload zsh/zprof

### Local configuration
# Settings can be customized inside ~/.zshenv.local.
export DIRCOLORS_FILE=${DIRCOLORS_FILE:-$HOME/Preferences/zsh/plugins/LS_COLORS/LS_COLORS}
export FORTUNES_DIRECTORY=${FORTUNES_DIRECTORY:-$HOME/code/fortune-tvshows/fortunes}

### NOTES
#
# About `autoload -Uz`: it means to disable alias expansion while loading the function and to force
# zsh emulation. I don't see why zsh emulation shouldn't be used by default though.
# See also: http://bewatermyfriend.org/p/2012/003/

### OPTIONS

# Make cd push the old directory onto the directory stack.
setopt auto_pushd

# Report the status of background and suspended jobs before exiting a shell with job control; a
# second attempt to exit the shell will succeed.
setopt check_jobs

# 03/08/2016 - This causes errors with "chef" hostname completion :(
# If unset, the cursor is set to the end of the word if completion is
# started. Otherwise it stays there and completion is done from both
# ends.
# setopt complete_in_word

# Try to correct the spelling of commands.
setopt correct

# Perform = filename expansion (e.g. echo =ssh -> /usr/bin/ssh)
setopt equals

# Treat the `#', `~' and `^' characters as part of patterns for filename generation, etc.
setopt extended_glob

# Try to make the completion list smaller (occupying less lines) by printing the matches in columns
# with different widths.
setopt list_packed

# List jobs in the long format by default.
setopt long_list_jobs

# Report the status of background jobs immediately, rather than waiting until just before printing a
# prompt.
setopt notify

# If numeric filenames are matched by a filename generation pattern, sort the filenames numerically
# rather than lexicographically.
setopt numeric_glob_sort

# Print the exit value of programs with non-zero exit status.
setopt print_exit_value

# Parameter expansion, command substitution and arithmetic expansion are performed in prompts.
setopt prompt_subst

# Don't push multiple copies of the same directory onto the directory stack.
setopt pushd_ignore_dups

# Allow the short forms of for, repeat, select, if, and function constructs.
setopt short_loops

# Allow comments even in interactive shells.
setopt interactive_comments

# Remove any right prompt from display when accepting a command line. This may be useful with
# terminals with other cut/paste methods.
setopt transient_rprompt

# Regular expression matching with the =~ operator will use Perl-Compatible Regular Expressions from
# the PCRE library, if available.
# Doesn't work on macOS Monterey's version of zsh.
# setopt rematch_pcre

# Assume that the terminal displays combining characters correctly. (i.e. UTF-8)
[[ $ZSH_VERSION == <5->.* ]] && setopt combining_chars

#### Disabled options

# Disable bell alert
setopt NO_beep

# Output flow control via start/stop characters (usually assigned to ^S/^Q) is disabled in the
# shell's editor.
setopt NO_flow_control

# Do not send the HUP signal to running jobs when the shell exits.
setopt NO_hup

# Query the user before executing `rm *' or `rm path/*'.
setopt NO_rm_star_silent

### FUNCTIONS
function exists() { which $1 &> /dev/null }

urlencode() { python3 -c "import sys, urllib.parse; print(urllib.parse.quote_plus(sys.argv[1]))" $@ }
urldecode() { python3 -c "import sys, urllib.parse; print(urllib.parse.unquote_plus(sys.argv[1]))" $@ }

teprego() {
    echo -e "$(tput setaf 1)sudo$(tput sgr0) â†’ $(fc -ln -1)"
    eval "sudo $(fc -ln -1)"
}

### ENVIRONMENT
# Bind environment variable to arrays (e.g. $perl5lib[@]).
declare -T LD_LIBRARY_PATH ld_library_path
declare -T PERL5LIB perl5lib
declare -T PYTHONPATH pythonpath

# Ansible pls.
export ANSIBLE_NOCOWS=1

# Send a notifications when someone logs in into the same machine.
watch=(notme)
LOGCHECK=300            # check every 5 min for login/logout activity
WATCHFMT='%n %a %l from %m at %t.'

# report about cpu-/system-/user-time of command if running longer than 5 seconds.
# REPORTTIME=5

# Disable history files for mysql client and less.
export MYSQL_HISTFILE=/dev/null
export LESSHISTFILE=/dev/null

### HISTORY
setopt append_history
setopt extended_history
setopt hist_ignore_dups
setopt hist_no_store
setopt hist_verify
setopt hist_ignore_space
setopt hist_expire_dups_first
SAVEHIST=10000
HISTSIZE=12000

# set the history file
HISTFILE=$HOME/.history

### COMMANDS CONFIGURATION
export LESS="--clear-screen --ignore-case --LONG-PROMPT --RAW-CONTROL-CHARS --tabs=4 --hilite-unread --status-column --window=5"
export PAGER="less"

# Colors in man pages, without having to use `most`.
# http://nion.modprobe.de/blog/archives/572-less-colors-for-man-pages.html
export LESS_TERMCAP_mb=$'\E[01;31m'
export LESS_TERMCAP_md=$'\E[01;31m'
export LESS_TERMCAP_me=$'\E[0m'
export LESS_TERMCAP_se=$'\E[0m'
export LESS_TERMCAP_so=$'\E[01;44;33m'
export LESS_TERMCAP_ue=$'\E[0m'
export LESS_TERMCAP_us=$'\E[01;32m'

# Sets vim or vi as the default editor.
if (( $+commands[vim] )); then
    export EDITOR=vim
    export VISUAL=vim
elif (( $+commands[vi] )); then
    export EDITOR=vi
    export VISUAL=vi
fi

export GREP_COLOR='1;32'

# LS OPTIONS
ls_options='--group-directories-first'
[[ $UID = 0 ]] && ls_options+='A'

### ZSH MODULES
# The zsh/complist module offers three extensions to completion listings: the ability to highlight
# matches in such a list, the ability to scroll through long lists and a different style of menu
# completion.
zmodload zsh/complist

# Use human-friendly key identifiers.
zmodload zsh/terminfo
typeset -g -A keyinfo
keyinfo=(
  'Control'   '\C-'
  'Escape'    '\e'
  'Meta'      '\M-'
  'F1'        "$terminfo[kf1]"
  'F2'        "$terminfo[kf2]"
  'F3'        "$terminfo[kf3]"
  'F4'        "$terminfo[kf4]"
  'F5'        "$terminfo[kf5]"
  'F6'        "$terminfo[kf6]"
  'F7'        "$terminfo[kf7]"
  'F8'        "$terminfo[kf8]"
  'F9'        "$terminfo[kf9]"
  'F10'       "$terminfo[kf10]"
  'F11'       "$terminfo[kf11]"
  'F12'       "$terminfo[kf12]"
  'Backspace' "$terminfo[kbs]"
  'Insert'    "$terminfo[kich1]"
  'Home'      "$terminfo[khome]"
  'PageUp'    "$terminfo[kpp]"
  'Delete'    "$terminfo[kdch1]"
  'End'       "$terminfo[kend]"
  'PageDown'  "$terminfo[knp]"
  'Up'        "$terminfo[kcuu1]"
  'Left'      "$terminfo[kcub1]"
  'Down'      "$terminfo[kcud1]"
  'Right'     "$terminfo[kcuf1]"
  'BackTab'   "$terminfo[kcbt]"
)

### BINDINGS
# Set META+delete to work like it does in Bash.
autoload -Uz select-word-style
select-word-style bash

# emacs bindings for ZLE.
bindkey -e

bindkey "${keyinfo[PageUp]}" up-line-or-history
bindkey "${keyinfo[PageDown]}" down-line-or-history
# shift+tab: like TAB but backwards.
bindkey  '[Z' reverse-menu-complete
bindkey  '^z' undo                      # CTRL+z per undo di expansion e completion
bindkey  '\C-w' kill-region

# sudo
# META+s to prefix "sudo" to the current command-line.
_add-sudo() { [[ $BUFFER != sudo\ * ]] && LBUFFER="sudo $LBUFFER" }
zle -N add-sudo _add-sudo
bindkey '\es' add-sudo

# META+e to edit the current command-line with $EDITOR.
autoload -Uz edit-command-line
zle -N edit-command-line
bindkey '\ee' edit-command-line

# META+M copies the previous word in the current command-line.
bindkey "^[m" copy-prev-shell-word

# autoload -U zkbd
# Eseguire zkbd per compilare una lista di variabili associate ai tasti
#source ~/.zkbd/$TERM-$VENDOR-$OSTYPE
#    [[ -n ${key[Left]} ]] && bindkey "${key[Left]}" backward-char
#    [[ -n ${key[Right]} ]] && bindkey "${key[Right]}" forward-char
#    # etc.

# idea from: zsh-lovers
insert-datestamp() { LBUFFER+=${(%):-'%D{%d-%m-%Y}'}; }
zle -N insert-datestamp
# C-e d -- insert current date dd-mm-YYYY
bindkey '^Ed' insert-datestamp

# https://github.com/junegunn/fzf/blob/764316a53d0eb60b315f0bbcd513de58ed57a876/shell/key-bindings.zsh
fzf-history-widget() {
    local selected num
    setopt localoptions noglobsubst noposixbuiltins pipefail no_aliases 2> /dev/null
    selected=( $(fc -rl 1 | perl -ne 'print if !$seen{(/^\s*[0-9]+\**\s+(.*)/, $1)}++' |
        FZF_DEFAULT_OPTS="--height ${FZF_TMUX_HEIGHT:-80%} $FZF_DEFAULT_OPTS -n2..,.. --tiebreak=index --bind=ctrl-r:toggle-sort,ctrl-z:ignore $FZF_CTRL_R_OPTS --query=${(qqq)LBUFFER} +m" fzf) )
    local ret=$?
    if [ -n "$selected" ]; then
        num=$selected[1]
        if [ -n "$num" ]; then
            zle vi-fetch-history -n $num
        fi
    fi
    zle reset-prompt
    return $ret
}

if exists fzf; then
    zle     -N   fzf-history-widget
    bindkey '^R' fzf-history-widget
fi

# extracts the command part of a command line.
# from: https://github.com/junegunn/fzf/blob/master/shell/completion.zsh
fzf-extract-command() {
    local token tokens
    tokens=(${(z)1})
    for token in $tokens; do
        token=${(Q)token}
        if [[ "$token" =~ [[:alnum:]] && ! "$token" =~ "=" ]]; then
            echo "$token"
            return
        fi
    done
    echo "${tokens[1]}"
}

# generates completion candidates for commands that expects a directory.
# correspond to '_fzf_compgen_dir' from https://github.com/junegunn/fzf/blob/master/shell/completion.zsh
compgen_fn() {
    if exists fd; then
        # 'fd' is much smarter than find in dealing with ignored files, VCS directories and so on.
        # NOTE: I might need to use the "-L" flag, like in the 'find' command below.
        fd --type directory '.*' "$1" | sed 's@^\./@@'
    else
        command find -L "$1" \
            -name .git -prune -o \
            -name .hg -prune -o \
            -name .svn -prune -o \
            -name venv -prune -o \
            -type d -a \
            -not -path "$1" -print 2> /dev/null | sed 's@^\./@@'
    fi
}

# completion function that only works on directories; it's a mish mash of several functions from
# https://github.com/junegunn/fzf/blob/master/shell/completion.zsh
# _fzf_dir_completion, __fzf_generic_path_completion, fzf-completion
fzf-dir-completion() {
    local cmd tokens lbuf tail trigger prefix dir leftover base

    # Split the result of the expansion into words using shell parsing to find the words (man zshexpn)
    tokens=(${(z)LBUFFER})
    if [ ${#tokens} -lt 1 ]; then
        zle expand-or-complete
        return
    fi

    cmd=$(fzf-extract-command "$LBUFFER")
    if [[ "$cmd" != "cd" ]]; then
        # default completion
        zle expand-or-complete
        return
    fi

    trigger="**"
    lbuf=$LBUFFER
    # grab the "tail" of $LBUFFER; the syntax is "${name:offset}" in zshexpn. Basically it gets
    # a string of the length of $trigger (i.e. "**") from the end of $LBUFFER.
    tail=${LBUFFER:$(( ${#LBUFFER} - ${#trigger} ))}

    # only do things if there's at least 1 token and the trigger was found
    if [ ${#tokens} -gt 1 -a "$tail" = "$trigger" ]; then
        # set $prefix to the last token without including the $trigger string
        prefix=${tokens[-1]:0:-${#trigger}}
        # if the length of the last token is non-zero then sets $lbuf to $lbuf minus the length of the last token;
        # essentially it strips the last token from $lbuf.
        [ -n "${tokens[-1]}" ] && lbuf=${lbuf:0:-${#tokens[-1]}}

        base="$prefix"
        suffix="/"
        tail=""

        setopt local_options no_nomatch
        # Evaluate completion prefix (examples: $HOME**, ~username**, ~username/foo**)
        # https://github.com/junegunn/fzf/commit/2b19c0bc685fc2f726b977d161e6ce720a4d04a8
        eval "base=$base"
        [[ $base = *"/"* ]] && dir="$base"
        while [ 1 ]; do
            if [[ -z "$dir" || -d ${dir} ]]; then
                # this is the "${name/pattern/repl}" syntax in zshexpn; also note that "repl" can be empty and in that case you can omit the final "/".
                # sets $leftover to $base with $dir stripped from the start of the string.
                leftover=${base/#"$dir"}
                # strip initial "/" from $leftover
                leftover=${leftover/#\/}

                [ -z "$dir" ] && dir='.'
                # if $dir is not "/" then strip "/" from the end of $dir
                [ "$dir" != "/" ] && dir="${dir/%\//}"
                matches=$(eval "compgen_fn $(printf %q "$dir")" | fzf --height 40% --reverse --bind=ctrl-z:ignore -q "$leftover" | while read item; do echo -n "${(q)item}$suffix "; done)
                # remove empty spaces from the end of $matches; see "PARAMETER EXPANSION", ${name%pattern} and ${name%%pattern}
                matches=${matches% }
                if [ -n "$matches" ]; then
                    LBUFFER="$lbuf$matches$tail"
                fi
                zle reset-prompt
                break
            fi
            dir=$(dirname "$dir")
            dir=${dir%/}/
        done
    else
        zle expand-or-complete
    fi
}

if exists fzf; then
    # creates a user defined widget
    zle -N fzf-dir-completion
    # bind TAB to it
    bindkey '^I' fzf-dir-completion
fi

### AUTOLOADS
# Add my own functions collections to fpath, for autoload to work.
# See also:
# http://unix.stackexchange.com/questions/33255/how-to-define-and-load-your-own-shell-function-in-zsh
typeset -U fpath
[[ -d ~/Preferences/zsh/scripts ]] && fpath+=~/Preferences/zsh/scripts
[[ -d ~/Preferences/zsh/functions ]] && fpath+=~/Preferences/zsh/functions

# if there's a local functions dir, prepend it to fpath to override the custom zsh functions.
if [[ -d ~/.zsh-work/functions ]]; then
    fpath=(~/.zsh-work/functions $fpath)
fi

# Autoload any custom function that I really use
useful_autoloads=(gh-link ssh ssh_master_shutdown whatwhen apple-logo unix2date http-server quote-for-knife set-iterm2-title github-whoami)
for fn in $useful_autoloads; do autoload -Uz $fn; done

# Autoload some nice zsh functions.
autoload -Uz zcalc zmv zargs

### PROMPT
# load zsh-notify first, as it needs to set up the first "precmd" hook before all the others,
# to be able to access the original $? from the last command (and not from the last hook)
source_if_exists "$HOME/dev/zsh-notify/zsh-notify.zsh"

# Use the prompt framework for our own prompt (see ~/.zsh/functions/prompt_piger_setup).
autoload -U promptinit
promptinit

# iTerm2 shell integration
# Needs to be loaded before the prompt since it do stuff with it.
if [[ $TERM_PROGRAM == "iTerm.app" && -e $HOME/.iterm2_shell_integration.zsh ]]; then
    export ITERM2_SQUELCH_MARK=1
    source $HOME/.iterm2_shell_integration.zsh
fi

autoload -Uz prompt_piger_setup
prompt piger

### OS SPECIFIC
if [[ $OSTYPE = darwin* ]]; then
    # top comodo
    alias itop="top -u -s 5 -stats pid,username,command,cpu,time,mem,vsize,ppid,state"

    # lock screen
    alias afk="pmset displaysleepnow"

    # disable the "log" builtin command, to not conflict with /usr/bin/log
    disable log

    # start the screensaver
    alias screensaver='/System/Library/CoreServices/ScreenSaverEngine.app/Contents/MacOS/ScreenSaverEngine'

    # ls
    if exists gls && [[ "$TERM" != dumb ]]; then
        alias ls="gls --color=auto $ls_options"
        (( $+commands[gdircolors] )) && test -e $DIRCOLORS_FILE && eval $(gdircolors -b $DIRCOLORS_FILE)
    fi

    export CLICOLOR=1

    # Trasforma la man page in PDF e la apre con Preview, votamazzen.
    man-preview() { man -t "$@" | open -f -a Preview }

    # print Finder directory
    pfd() {
        osascript 2>/dev/null <<EOF
    tell application "Finder"
            return POSIX path of (target of window 1 as alias)
    end tell
EOF
    }

    # cd to Finder directory
    cdf() { eval cd "$(osascript -e 'tell app "Finder" to return the quoted form of the POSIX path of (target of window 1 as alias)' 2>/dev/null)" }

    # print Finder selection
    pfs() {
        osascript 2>/dev/null <<EOF
        set output to ""
        tell application "Finder" to set the_selection to selection
        set item_count to count the_selection
        repeat with item_index from 1 to count the_selection
          if item_index is less than item_count then set the_delimiter to "\n"
          if item_index is item_count then set the_delimiter to ""
          set output to output & ((item item_index of the_selection as alias)'s POSIX path) & the_delimiter
        end repeat
EOF
    }

    # cli volume control
    vol() {
        if [[ -n $1 ]]; then
            osascript -e "set volume output volume $1"
        else
            osascript -e "output volume of (get volume settings)"
        fi
    }

    # locate with Spotlight
    locatemd() {
        mdfind "kMDItemDisplayName == '$@'wc"
    }

    # Flush DNS cache
    alias flush_dns_cache='dscacheutil -flushcache'

elif [[ $OSTYPE = linux* ]]; then
    alias ls="ls --color=auto $ls_options"

    if (( ! $+commands[gnome-open] )); then
        alias gnome-open='echo quei maledetti di GNOME hanno deciso che ora si chiama gvfs-open, gli morisse la gente attorno'
    fi

    alias grep='grep --color=auto'

    # LS_COLORS
    (( $+commands[dircolors] )) && test -e $DIRCOLORS_FILE && eval $(dircolors -b $DIRCOLORS_FILE)

elif [[ $OSTYPE = openbsd* ]]; then
    if (( $+commands[gls] )); then
        alias ls="gls --color=auto $ls_options"
    else
        alias ls="ls $ls_options"
    fi

    alias pfdump="tcpdump -n -e -ttt -i pflog0"
    alias pfrerules="pfctl -F rules -R -f /etc/pf.conf"
    alias pfrenat="pfctl -F nat -N -f /etc/pf.conf"
fi # end if $OSTYPE = ...

### ALIASES
# Aliases e altri comandi che non uso mai perche' sono SCEMO
# ----------------------------------------------------------
# man zshexpn -> search Glob Qualifier
alias h='fc -l -t "%d/%m/%Y %H:%M" -D'
alias dirdu="du -Hhs *(/,@)"    # du -h di ogni dir presente
alias ..='cd ..'
alias ...='cd ../..'

# disable spell correction
alias rm="nocorrect rm"

# disable globbing (i.e. do not expand arguments like "*" to the actual list of files)
alias scp="noglob scp"

# interactive versions
alias rmi="rm -i"
alias mvi="mv -i"
alias cpi="cp -i"

# alias globali, che pero' non gradisco.
alias -g L='|less'
# alias -g H='|head'
# alias -g T='|tail'

alias pwgen_strong='pwgen -y1 15 20'

# stampa la penultima riga di un input
penultima() { awk '{ lines[NR] = $0 } END { print lines[NR-1] }' }

today() { date "+%Y-%m-%d" }

# emacsclient + newframe
alias e='emacsclient -c'

# ruby merda
alias be='bundle exec'

tableflip() { echo '(â•¯Â°â–¡Â°ï¼‰â•¯ï¸µ â”»â”â”»' }

# Use Python to pretty-print JSON.
alias json.tool='python -m json.tool'

### COMPLETION
# Completion della ZSH, perche' la pigerrimitudo e' una virtute.
# --------------------------------------------------------------
#
# :completion:function:completer:command:argument:tag

# zsh-completions
# OS X: install with "brew install zsh-completions"
[[ -d /usr/local/share/zsh-completions/ ]] && fpath=(/usr/local/share/zsh-completions $fpath)

# compinstall, dilemma TODO
zstyle :compinstall filename '~/.zshrc'

# questo va all'inizio, altrimenti poi non ho `compdef` o altri comandi.
autoload -Uz compinit
compinit

# supporto bash completion (da chiamare DOPO 'compinit')
autoload -Uz bashcompinit
bashcompinit

# Lista di completers
# _prefix deve stare prima di _approximate, senno' e' OLOCAUSTO
# _ignored completa file/dir che per altre impostazioni verrebbero ignorati
#zstyle ':completion:::::' completer _complete _prefix _approximate _ignored

# Forza il rehash per ogni uso della completion (ie: premi tab).
# http://zshwiki.org/home/examples/compquickstart?s=rehash
_force_rehash() {
    (( CURRENT == 1 )) && rehash
    return 1    # Because we didn't really complete anything.
}
zstyle ':completion:*' rehash true      # rehash automatico, ma non sembra funzionare... TODO

# Abilita i messaggi della completion, aggiunge bold ad alcune stringhe
# e raggruppa i risultati per tipologia (fidati, e' MEGLIO COSI')
zstyle ':completion:*:messages' format %d
zstyle ':completion:*:warnings' format '%BNo matches%b: %d'
zstyle ':completion:*:descriptions' format '%B%d%b'
# raggrouppa l'output
zstyle ':completion:*' group-name ''
zstyle ':completion:*' list-separator '-->'
# Non completare i nomi delle funzioni che iniziano per '_'
#zstyle ':completion::complete:*:functions' ignored-patterns '_*'
# che sia cosi'?
zstyle ':completion:*:functions' ignored-patterns '_*'

# separa i man per sezione
zstyle ':completion:*:manuals' separate-sections true

# Mostra le descrizioni per cio' che viene completato, ad esempio le opzioni di ls;
# quando manca la descrizione, prova a "indovinare"
zstyle ':completion:*' verbose yes
zstyle ':completion:*' auto-description 'specify: %d'

# Utilizza un pager interno quando i risultati della completion sono troppi
zstyle ':completion:*:default' list-prompt '%S%M matches%s'
bindkey -M listscroll q send-break      # binda 'q' per uscire dal pager

# Limit this fuckung "zsh: do you wish to see all NNN possibilities (NNN
# lines)?" downward (default is 100). Only ask before displaying
# completions if doing so would scroll. (strcat.de)
#LISTMAX=0

# Completion approssimativa, permette un errore ogni 3 caratteri
zstyle ':completion:*:corrections' format '%B%d (errors: %e)%b'
zstyle ':completion:::::' completer _force_rehash _complete _prefix _approximate _ignored
# allow 1 error per 3 characters typed:
zstyle -e ':completion:*:approximate:*' max-errors 'reply=( $(( ($#PREFIX+$#SUFFIX)/3 ))numeric)'
# Completa cose tipo: gzip _-d -> gzip --decompress
zstyle ':completion::approximate*:*' prefix-needed false

# Case insensitive: converte solo le minuscole in maiuscole, perche' come dicono
# NEL LIBRO, per scrivere le maiuscole devi premere anche shift, ed e' quindi piu'
# probabile che sia una scelta deliberata e non un errore di battitura
# INOLTRE, implementa la Partial Completion, usando '/' come carattere anchor: cio'
# permette finezze come cd /u/l/b -> cd /usr/local/bin -- e' come premere TAB su ogni
# '/'
zstyle ':completion:*:(^approximate):*' matcher-list \
        'r:|[/]=* r:|=* m:{a-z}={A-Z}'

# titoli [from: https://github.com/seebi/zshrc]
zstyle ':completion:*:messages' format $'\e[01;35m -- %d -- \e[00;00m'
zstyle ':completion:*:warnings' format $'\e[01;31m -- No Matches Found -- \e[00;00m'
zstyle ':completion:*:descriptions' format $'\e[01;33m -- %d -- \e[00;00m'
zstyle ':completion:*:corrections' format $'\e[01;33m -- %d -- \e[00;00m'

# statusline for many hits [from: https://github.com/seebi/zshrc]
zstyle ':completion:*:default' select-prompt $'\e[01;35m -- Match %M %P -- \e[00;00m'

# Prefix Completion: se il cursore e' nel mezzo di una word, zsh completa come se il
# cursore si trovasse a fine word; l'opposto si ottiene abilitando complete_in_word.
# Un altro approccio consiste nel completare ignorando completamente il suffix...
zstyle ':completion::prefix:::' completer _complete
zstyle ':completion:*:prefix:*' add-space true  # aggiunge anche uno spazio

# Esclusioni
# Avendo '_ignored' tra i completer, le seguenti regole verranno ignorate nel caso
# in cui non ci sia altro da completare
zstyle ':completion:*:*:cd:*' ignored-patterns '(*/|)(CVS)'
# Evita di completare cio' che e' gia' sulla command line
# Questo e' AAAH, sputtana la completion e il Tab non cycla piu' tra i possibili match :-(
#zstyle ':completion:*:(rm|rmdir|grep|vim|vi):*' ignore-line true
# Non completare le directory se la completion "non ha senso" (../$PWD non ha senso)
#zstyle ':completion:*' ignore-parents parent pwd
# meglio?
zstyle ':completion:*:cd:*' ignore-parents parent pwd
# Per abilitare la completion di "cd ../"
zstyle ':completion:*' special-dirs true

# Completa cio' che non ESISTE, UN FILM DI ZARRO SUCUNI
zstyle ':completion::*:(-command-|export):*' fake-parameters DISPLAY:scalar \
    LD_LIBRARY_PATH:array COLUMNS:scalar LANG:scalar LC_ALL:scalar CVSROOT:scalar \
    PERL5LIB:array PYTHONPATH:array DJANGO_SETTINGS_MODULE:scalar \
    SSH_AUTH_SOCK:scalar DYLD_LIBRARY_PATH:array DYLD_FALLBACK_LIBRARY_PATH:array

# Completion per `kill`: mostra una lista di processi con la percentuale di CPU
# utilizzata, e su linux come bonus mostra i processi come un albero
# gerarchico.
if [[ $OSTYPE == linux* ]]; then
    zstyle ':completion::*:kill:*:*' command 'ps xf -U $USER -o pid,%cpu,%mem,cmd'
else
    # -r -- sort by CPU usage
    zstyle ':completion:*:processes' command 'ps x -U $USER -r -o pid,%cpu,%mem,tt,args'
fi
# ... e ovviamente i colori. [from: https://github.com/seebi/zshrc]
zstyle ':completion::*:kill:*:processes' list-colors '=(#b) #([0-9]#)*=0=01;32'

# cache
zstyle ':completion:*' use-cache on
zstyle ':completion:*' cache-path ~/.zsh/.zcompcache

# Completion con i colori di ls
zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}

# completion from history [ https://github.com/seebi/zshrc/blob/master/options.zsh ]
zle -C hist-complete complete-word _generic
zstyle ':completion:hist-complete:*' completer _history
bindkey '^X^X' hist-complete

# extend ssh host completion with chef nodes. Just create a list of hostnames in ~/.chef_hosts
add_chef_nodes_to_hosts_completion() {
    zmodload zsh/mapfile
    local _ssh_hosts
    zstyle -s ':completion:*:hosts' hosts _ssh_hosts
    _ssh_hosts+=("${(f@)mapfile[$HOME/.chef_hosts]}")
    zstyle ':completion:*:hosts' hosts $_ssh_hosts
}

if [[ -s $HOME/.chef_hosts ]]; then
    add_chef_nodes_to_hosts_completion

    # check if the chef host file is stale
    if vpn_status >/dev/null; then
        if [[ $(( $(date +"%s") - $(stat -f "%m" $HOME/.chef_hosts) )) -gt 14200 ]]; then
            echo "WARNING: the chef hosts file $HOME/.chef_hosts is older than 4 hours; refreshing now."
            lckdo $HOME/.lock_chef $HOME/Preferences/bin/zsh_chef_completion.sh &
        fi
    fi
fi

# use hosts completion also for tmux-cssh
compdef _hosts tmux-cssh
# and also for bssh
compdef _hosts bssh

### WELCOME
[[ -e $HOME/Preferences/bin/welcome.sh ]] && $HOME/Preferences/bin/welcome.sh

# Emacs tramp support
# Sets the terminal to something simple so that emacs doesn't gets confused.
[[ $TERM == "dumb" ]] && unsetopt zle && PS1='$ '

### PLUGINS AND STUFF
source_if_exists "$HOME/Preferences/zsh/keephack"
source_if_exists "$HOME/Preferences/zsh/plugins/z/z.sh"

### LOCAL SETTINGS
source_if_exists "$HOME/.zshrc.local"

# zprof
